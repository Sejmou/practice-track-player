import React, { Component } from 'react';
import { Box, Button } from '@mui/material';

import { createPointMarker, createSegmentMarker } from './MarkerFactories';
import { createSegmentLabel } from './SegmentLabelFactory';

import classes from './WaveformView.module.css';
import Peaks from 'peaks.js';

// See https://github.com/bbc/peaks.js#generating-waveform-data for details on how peaks.js actually generates the audio waveform
type Props = {
  audioUrl: string;
  audioContentType: string;
  /**
   * URI pointing to precomputed waveform data (either binary .dat file or JSON) generated by https://github.com/bbc/audiowaveform)
   *
   * If supplied, neither audioContext nor audioBuffer are required
   */
  waveformDataUri?: string;
  /**
   * used by peaks.js to generate (and then display) the waveform data from the audio element src (will fetch AudioBuffer internally)
   *
   * If supplied, neither waveformDataUri nor audioBuffer are required
   */
  audioContext?: AudioContext;
  /**
   * waveform data computed using decodeData() of some AudioContext
   *
   * If supplied, neither waveformDataUri nor audioContext are required
   */
  audioBuffer?: AudioBuffer;
  audioElement: HTMLAudioElement;
  setSegments: Function;
  setPoints: Function;
};

// this file and all related files were adapted from https://github.com/chrisn/peaksjs-react-example
// the initial code was written in JS and I have very little knowledge of this library
// so, the code that made all of this kinda work is very ugly and hacky lol
class WaveformView extends Component<Props> {
  constructor(props: Props) {
    super(props);

    this.zoomviewWaveformRef = React.createRef();
    this.overviewWaveformRef = React.createRef();
    // this.audioElementRef = React.createRef();
    this.peaks = null;
  }

  zoomviewWaveformRef: any;
  overviewWaveformRef: any;
  // audioElementRef: any;
  peaks: any;

  render() {
    return (
      <div>
        <div
          className={classes['zoomview-container']}
          ref={this.zoomviewWaveformRef}
        ></div>
        <div
          className={classes['overview-container']}
          ref={this.overviewWaveformRef}
        ></div>

        {/* {this.renderButtons()} */}
      </div>
    );
  }

  renderButtons() {
    return (
      <Box>
        <Button onClick={this.zoomIn}>Zoom in</Button>&nbsp;
        <Button onClick={this.zoomOut}>Zoom out</Button>&nbsp;
        <Button onClick={this.addSegment}>Add Segment</Button>&nbsp;
        <Button onClick={this.addPoint}>Add Point</Button>&nbsp;
        <Button onClick={this.logMarkers}>Log segments/points</Button>
      </Box>
    );
  }

  componentDidMount() {
    this.initPeaks();
  }

  componentDidUpdate(prevProps: Props, prevState: any, snapshot: any) {
    if (this.props.audioUrl === prevProps.audioUrl) {
      return;
    }

    this.initPeaks();
  }

  initPeaks() {
    const viewContainerOptions: Peaks.ViewContainerOptions = {
      containers: {
        overview: this.overviewWaveformRef.current,
        zoomview: this.zoomviewWaveformRef.current,
      },
    };

    let remoteWaveformDataOpts: Peaks.RemoteWaveformDataOptions | null = null;

    if (this.props.waveformDataUri) {
      remoteWaveformDataOpts = {
        dataUri: {
          arraybuffer: this.props.waveformDataUri,
        },
      };
    }

    let webAudioOpts: Peaks.WebAudioOptions | null = null;

    if (this.props.audioContext) {
      webAudioOpts = {
        webAudio: {
          audioContext: this.props.audioContext,
        },
      };
    }

    if (this.props.audioBuffer) {
      webAudioOpts = {
        webAudio: {
          audioBuffer: this.props.audioBuffer,
        },
      };
    }

    const audioOpts = webAudioOpts
      ? webAudioOpts
      : remoteWaveformDataOpts
      ? remoteWaveformDataOpts
      : null;

    if (!audioOpts) {
      throw Error(
        'Please provide either waveformData or audioContext or audioBuffer!'
      );
    }

    const optionalOptions: Peaks.OptionalOptions = {
      // mediaElement: this.audioElementRef.current,
      mediaElement: this.props.audioElement,
      keyboard: true,
      logger: console.error.bind(console),
      createSegmentMarker: createSegmentMarker,
      createSegmentLabel: createSegmentLabel,
      createPointMarker: createPointMarker,
    };

    const options: Peaks.PeaksOptions = {
      ...viewContainerOptions,
      ...optionalOptions,
      ...audioOpts,
    };

    // this.audioElementRef!.current!.src = this.props.audioUrl;

    if (this.peaks) {
      this.peaks.destroy();
      this.peaks = null;
    }

    Peaks.init(options, (err, peaks) => {
      this.peaks = peaks;
      this.onPeaksReady();
    });
  }

  componentWillUnmount() {
    if (this.peaks) {
      this.peaks.destroy();
    }
  }

  zoomIn() {
    if (this.peaks) {
      this.peaks.zoom.zoomIn();
    }
  }

  zoomOut() {
    if (this.peaks) {
      this.peaks.zoom.zoomOut();
    }
  }

  addSegment() {
    if (this.peaks) {
      const time = this.peaks.player.getCurrentTime();

      this.peaks.segments.add({
        startTime: time,
        endTime: time + 10,
        labelText: 'Test Segment',
        editable: true,
      });
    }
  }

  addPoint() {
    if (this.peaks) {
      const time = this.peaks.player.getCurrentTime();

      this.peaks.points.add({
        time: time,
        labelText: 'Test Point',
        editable: true,
      });
    }
  }

  logMarkers() {
    if (this.peaks) {
      this.props.setSegments(this.peaks.segments.getSegments());
      this.props.setPoints(this.peaks.points.getPoints());
    }
  }

  onPeaksReady() {
    // Do something when the Peaks instance is ready for use
    console.log('Peaks.js is ready');
  }
}

export default WaveformView;
